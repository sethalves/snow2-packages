#! /bin/sh
#| -*- scheme -*-
exec csi -s $0 "$@"
|#

(use posix)
(use srfi-13)


(define-record-type <snow1-package>
  (make-snow1-package maintainer author homepage
                      description keywords license requires
                      version)
  snow1-package?
  (maintainer snow1-package-maintainer snow1-package-maintainer-set!)
  (author snow1-package-author snow1-package-author-set!)
  (homepage snow1-package-homepage snow1-package-homepage-set!)
  (description snow1-package-description snow1-package-description-set!)
  (keywords snow1-package-keywords snow1-package-keywords-set!)
  (license snow1-package-license snow1-package-license-set!)
  (requires snow1-package-requires snow1-package-requires-set!)
  (version snow1-package-version snow1-package-version-set!))


(define (read-package repo-name package-name)
  (let* ((package-file (string-append repo-name "/"
                                      package-name "/"
                                      package-name ".package"))
         (in-p (open-input-file package-file))
         (package-header (read in-p)))
    (close-input-port in-p)
    package-header))


(define (parse-snow1-package-header repo-name package-header)
  (let ((s1p (make-snow1-package '() '() '() '() '() '() '() "1.0")))

    (define key->get-and-set
      `((maintainer: (,snow1-package-maintainer
                      ,snow1-package-maintainer-set!))
        (author: (,snow1-package-author ,snow1-package-author-set!))
        (homepage: (,snow1-package-homepage ,snow1-package-homepage-set!))
        (description: (,snow1-package-description
                       ,snow1-package-description-set!))
        (keywords: (,snow1-package-description
                    ,snow1-package-description-set!))
        (license: (,snow1-package-license ,snow1-package-license-set!))
        (require: (,snow1-package-requires ,snow1-package-requires-set!))
        (provide: (#f #f))))

    (define (parse-child child)
      (cond ((and (list? child)
                  (not (null? child)))
             (let* ((child-type (car child))
                    (child-args (cdr child))
                    (set-and-get (assq child-type key->get-and-set)))
               (cond ((not set-and-get)
                      (error "unknown snow1 package child type" child-type))
                     (else
                      (let ((getter (car (cadr set-and-get)))
                            (setter (cadr (cadr set-and-get))))
                        (cond ((and getter setter)
                               (setter s1p (append (getter s1p)
                                                   child-args)))))))))
            (else
             (error "malformed package child" child))))

    (cond ((and (list? package-header)
                (not (null? package-header))
                (not (null? (cdr package-header)))
                (eq? (car package-header) 'package*))
           (let-values (((name version)
                         (convert-package-name repo-name
                                               (cadr package-header))))
             (snow1-package-version-set! s1p version)
             (let loop ((childs (cddr package-header)))
               (cond ((null? childs) s1p)
                     (else
                      (let ((child (car childs)))
                        (parse-child child)
                        (loop (cdr childs))))))))
          (else
           (error "malformed package" package-header)))))



(define (convert-package-name repo-name req)
  ;; if req is a symbol like genport/v1.1, return (values '(snow genport) 1.1)
  ;; if it's a list like (snow genport) return the (values '(snow genport) 1)
  (define (is-version s)
    (cond ((equal?
            (string-trim-right s (lambda (c)
                                   (memv c '(#\0 #\1 #\2 #\3 #\4 #\5
                                             #\6 #\7 #\8 #\9 #\.))))
            "v")
           (substring s 1 (string-length s)))
          (else
           #f)))

  (cond
   ((symbol? req)
    (let* ((s (symbol->string req))
           (t (string-tokenize s (char-set-complement (char-set #\/)))))
      (cond ((and (= (length t) 2)
                  (is-version (cadr t)))
             (values `(snow ,(string->symbol (car t)))
                     (is-version (cadr t))))
            (else
             (values `(,repo-name ,(string->symbol s)) "1.0")))))
   ((string? req)
    (values `(,(string->symbol repo-name) ,(string->symbol req)) "1.0"))
   ((list? req)
    (values req "1.0"))
   (else
    (error "malformed package name" req))))


(define (convert-requires repo-name reqs)
  (map
   (lambda (req)
     (let-values (((name version) (convert-package-name repo-name req)))
       name))
   reqs))


(define (s1-package->s2-package s1p repo-name package-name)
  (let ((url (repo-and-name->url repo-name package-name)))
    (let-values (((name version)
                  (convert-package-name repo-name package-name)))
      `(package
        (url ,url)
        (library
         (name ,name)
         (path ,(string-append repo-name "/" package-name ".sld"))
         (version ,(snow1-package-version s1p))
         ,@(if (not (null? (snow1-package-homepage s1p)))
               `((homepage ,@(snow1-package-homepage s1p)))
               '())

         ,@(if (not (null? (snow1-package-maintainer s1p)))
               `((maintainers ,@(snow1-package-maintainer s1p)))
               '())

         ,@(if (not (null? (snow1-package-author s1p)))
               `((authors ,@(snow1-package-author s1p)))
               '())

         ,@(if (not (null? (snow1-package-description s1p)))
               `((description ,@(snow1-package-description s1p)))
               '())

         ,@(if (not (null? (snow1-package-keywords s1p)))
               `((keywords ,@(snow1-package-keywords s1p)))
               '())

         ,@(if (not (null? (snow1-package-license s1p)))
               `((license ,@(snow1-package-license s1p)))
               '())

         ,@(if (not (null? (snow1-package-requires s1p)))
               `((depends ,@(convert-requires repo-name
                                              (snow1-package-requires s1p))))
               '()))
        ))))


(define (output-package-index s2p)
  (let ((string-port (open-output-string)))
    (pp s2p string-port)
    (let* ((result (get-output-string string-port))
           (result-lines
            (string-tokenize
             result (char-set-complement (char-set #\newline)))))
      (close-output-port string-port)

      (for-each
       (lambda (line)
         (display "  ")
         (display line)
         (newline))
       result-lines)
      )))



(define (repo-and-name->url repo-name package-name)
  (cond
   ((equal? repo-name "snow")
    (string-append
     "http://snow-repository.s3-website-us-east-1.amazonaws.com/"
     package-name ".tgz"))
   ((equal? repo-name "seth")
    (string-append
     "http://snow2.s3-website-us-east-1.amazonaws.com/"
     package-name ".tgz"))
   (else
    (error "don't know url for repository" repo-name))))


(define (main-program repo-name-and-package-names)
  (let ((repo-name (car repo-name-and-package-names))
        (package-names (cdr repo-name-and-package-names)))
    (for-each
     (lambda (package-name)
       (let* ((package-header (read-package repo-name package-name))
              (s1p (parse-snow1-package-header repo-name package-header))
              (s2p (s1-package->s2-package s1p repo-name package-name)))
         (output-package-index s2p)))
     package-names)))


(main-program (command-line-arguments))
